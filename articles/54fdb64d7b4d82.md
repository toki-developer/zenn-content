---
title: "Expo(React Native)でウィジェットを作るときのあれこれ"
emoji: "✨"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["reactnative", "expo", "swift", "ios"]
published: false
---

## 概要

勉強目的で自分が使うための習慣アプリを作ってみました！
その中でウィジェットの開発をしたので、その時に学んだことを残しておきます。

https://apps.apple.com/us/app/%E3%82%A6%E3%82%A3%E3%82%B8%E3%82%A7%E3%83%83%E3%83%88%E3%81%A7%E7%BF%92%E6%85%A3/id6754188081

## 前提

* iOS固有のネイティブコードは、基本的に`/ios`ディレクトリで管理されます。
* ネイティブコードをすべて自身で管理するのは大変なので、Expo CNGでは`/ios`ディレクトリを直接編集しません。
* `expo prebuild` コマンドを実行して、アプリ構成ファイル(`app.json`, `app.config.js`)の情報を元に `/ios`ディレクトリを自動更新・生成します。
* `/ios`ディレクトリは`expo prebuild`によって上書きされるため、ネイティブコードを独自に記述したい場合は、別の場所にコードを配置し、リンクさせる必要があります。

## プロジェクト作成と動作確認

:::message
XcodeやiOS simulatorの準備は完了している前提で進めます。
:::

プロジェクトを作成します
```
npx create-expo-app@latest zenn-widget-sample
```

作成したプロジェクトに移動します
```
cd zenn-widget-sample
```

アプリを起動します
```
npx expo prebuild -p ios
npm run ios
```

`npm run ios`実行後、iOS simulatorが自動で立ち上がらない場合は「i」キーを押してください。
`npm run ios`を実行したターミナルに以下の表示がされていると思います。
> › Press i │ open iOS simulator

アプリが起動できたらウィジェットの導入に進みます。

:::details アプリ起動のキャプチャ
![](https://storage.googleapis.com/zenn-user-upload/dbba31b5bccb-20251130.png)
:::

## ウィジェットの導入

### 利用するライブラリについて
現状、Expo公式ではウィジェットの開発のサポートをしていないため、Expo 開発者のEvan Bacon 氏によって開発された [expo-apple-targets](https://github.com/EvanBacon/expo-apple-targets) というライブラリ(Expo Configプラグイン)を利用しました。

このライブラリを使用すると`/targets/widget/`ディレクトリが作成され、`/targets/widget/`ディレクトリ内の編集のみでウィジェットの実装が可能になります。
これにより、`/ios`ディレクトリとのリンク設定が自動化されます。

※ 実験的な機能であり、将来的に破壊的変更の可能性もあります。しかし、これはウィジェット開発のためのSwiftライブラリではなく、Expoでウィジェットを利用可能にするためのライブラリです。そのため、もし別のソリューションが登場した場合でも、ウィジェットのコード（Swift）自体は比較的容易に移行できると考えています。

### ライブラリを利用して導入する

[公式の手順](https://github.com/EvanBacon/expo-apple-targets)に従ってウィジェットの導入を進めていきます。


:::details 公式の手順
![](https://storage.googleapis.com/zenn-user-upload/05d601bdf678-20251130.png)

翻訳 (DeepL)
1. Expoプロジェクトでnpx create-targetを実行し、Appleターゲットを生成します。
2. 生成するターゲットを選択します。ウィジェットから始めることをお勧めします（例: npx create-target widget）。これにより、必要なウィジェットファイルがルートディレクトリの/targetsに生成され、@bacons/apple-targetsがインストールされ、Expo Configプラグインがプロジェクトに追加されます。
3. Apple Team IDが既にお分かりの場合は、app.json内のios.appleTeamIdプロパティで設定してください。Xcodeの「署名と機能」タブで確認でき、必要に応じて後から設定可能です。
4. npx expo prebuild -p ios --clean を実行してXcodeプロジェクトを生成します。
5. Xcode（xed ios）でプロジェクトを開き、expo:targets/<target>フォルダ内でウィジェットを開発できます。
6. ビルド準備が整ったら、Xcodeでターゲットを選択しビルドしてください。
:::

コマンドを実行してAppleターゲットを生成します。
```
npx create-target
```
ターゲットを選択するように表示されるので「Widget」を選択します。
ネイティブに関わるapp.jsonの更新をしたので、prebuildしてからアプリを起動します。
```
npx expo prebuild -p ios --clean
npm run ios
```

iOS Simulatorでアイコンを長押しすると、ウィジェットを選択出来るようになっています。
試しに左から1つ目を選択すると、ウィジェットが表示されることを確認できました。
|アイコンを長押し|ウィジェットを表示|
|-|-|
|![](https://storage.googleapis.com/zenn-user-upload/993ad6b12cad-20251130.png)|![](https://storage.googleapis.com/zenn-user-upload/cb57f9595086-20251130.png)|

### 修正して動作確認
Xcodeを開きます。
```
xed ios
```
![](https://storage.googleapis.com/zenn-user-upload/c7d01679614d-20251130.png)

`expo:targets/widget`の中が修正する箇所になります。

試しに `expo:targets/widget/widgets.swift`を修正してみます。
```diff swift:expo:targets/widget/widgets.swift
    var body: some View {
        VStack {
            Text("Time:")
            Text(entry.date, style: .time)

+            Text("Hello Widget")
-            Text("Favorite Emoji:")
-            Text(entry.configuration.favoriteEmoji)
        }
    }
```

Swiftファイルを修正したため、`npm run ios`でビルドします。
今回はapp.jsonを修正していないのでprebuildは不要です。
```
npm run ios
```

:::message
既に`npm run ios`を実行中の場合、プロセスを停止せずに別のターミナルで再度`npm run ios`を実行すると、開発サーバーの起動が不要なため、ビルド時間を短縮できます。
:::

ウィジェットが変更されていることが確認できました。

![](https://storage.googleapis.com/zenn-user-upload/205ae14a762f-20251130.png)

これでウィジェットの開発を始める準備が完了しました。

## ウィジェットのコードを確認
### 自動生成されたコード
`npx create-target`によって自動生成されたコードを見ていきます。
以下の5つのSwiftファイルが存在します。
* index.swift
  * ルートファイル
  * widget、WidgetControl、WidgetLiveActivityを呼び出している
  * 新しいウィジェットを作成した場合は、ここに追加します。
* WidgetControl.swift
  * コントロールセンターなどに追加できる「Control」を提供するファイル
  * 今回の記事では対象外とします（未検証）。
* WidgetLiveActivity.swift
  * ロック画面などにリアルタイムの情報を表示できる「Live Activity」を定義するファイル
  * 今回の記事では対象外とします（未検証）。
* widget.swift
  * 先ほど確認したような通常のウィジェット機能用のファイル
  * 今回の記事では、このウィジェットを対象とします。
* AppIntent.swift
  * ウィジェットの設定用のAppIntentを定義するファイル
  * ウィジェット設定画面から値を設定できる


今回は通常のウィジェットの利用を想定しているので、`WidgetControl.swift` と `WidgetLiveActivity.swift` の修正は不要です。
`index.swift`からも該当コードを削除します。

```diff swift:expo:targets/widget/index.swift
@main
struct exportWidgets: WidgetBundle {
    var body: some Widget {
        // Export widgets here
        widget()
-        widgetControl()
-        WidgetLiveActivity()
    }
}
```

:::details 余談:コントロールセンターを確認
`widgetControl`の呼び出しを消す前はコントロールセンターに以下のようなアイコンが表示されますが、消すと表示されなくなります。
![](https://storage.googleapis.com/zenn-user-upload/051323302c55-20251130.png)
:::

### 通常のウィジェット関連のコード
主に`AppIntent.swift`と`widget.swift`を修正していきます。

#### AppIntent.swift
* WidgetConfigurationIntent
  * ウィジェットの編集画面から設定可能なパラメータなどを定義します。
  * widget.swiftから利用しています。

```diff swift:expo:targets/widget/AppIntent.swift
    @Parameter(title: "Favorite Emoji", default: "😃")
    var favoriteEmoji: String
```

|ウィジェットを長押し|ウィジェットを編集をタップ|
|-|-|
|![](https://storage.googleapis.com/zenn-user-upload/20227c84e4b4-20251130.png)|![](https://storage.googleapis.com/zenn-user-upload/154cc1277581-20251130.png)|

#### widget.swift
* widget
  * `index.swift`から呼び出される最上位の構造体を定義します。
* View (widgetEntryView)
  * ウィジェットのUI部分
* Entry (SimpleEntry)
  * 表示するデータや設定値を持つ構造体
* AppIntentTimelineProvider
  * placeholder
    * データがまだ取得できない場合などに表示されるEntryを定義します。
  * snapshot
    * ウィジェット追加時に表示されるサンプルデータのEntryを定義します。
  * timeline
    * データを更新するタイミングを定義します（例: 5分ごと、1時間ごとなど）。
    * 実際にウィジェットに表示するデータを取得します。

詳細については、以下の記事が参考になりました。
https://qiita.com/yuuka_____gf/items/604c29a71584206f23d3

## ウィジェットを実装してみる

データ取得用のクラスを作成し、サンプルデータを表示するまでの実装を行います。

### データ取得用のクラスを作成

`expo:targets/widget/DataManager.swift`ファイルを作成します。

```swift:expo:targets/widget/DataManager.swift
struct SampleModel: Identifiable {
  var id: String
  var name: String
}

class DataManager {
  static let shared = DataManager()
  
  func loadSampleData() -> [SampleModel] {
    var data = [
      SampleModel(id: "1", name: "hoge"),
      SampleModel(id: "2", name: "fuga")
    ]
    
    return data
  }
}
```

### データを取得して表示する

`DataManager`が返却する`SampleModel`の配列を受け取り、`SimpleEntry`に追加します。
`View`ではこの`SimpleEntry`のデータを利用して表示します。

更新タイミングは0時に一度としました。

```diff swift:expo:targets/widget/widget.swift
func placeholder(in context: Context) -> SimpleEntry {
-   SimpleEntry(date: Date(), configuration: ConfigurationAppIntent())
+   SimpleEntry(date: Date(), sampleList: [], configuration: ConfigurationAppIntent())
}

func snapshot(for configuration: ConfigurationAppIntent, in context: Context) async -> SimpleEntry {
-   SimpleEntry(date: Date(), configuration: ConfigurationAppIntent())
+   SimpleEntry(date: Date(), sampleList: [], configuration: ConfigurationAppIntent())
}
func timeline(for configuration: ConfigurationAppIntent, in context: Context) async -> Timeline<SimpleEntry> {
-    var entries: [SimpleEntry] = []
-
-    // Generate a timeline consisting of five entries an hour apart, starting from the current date.
-    let currentDate = Date()
-    for hourOffset in 0 ..< 5 {
-        let entryDate = Calendar.current.date(byAdding: .hour, value: hourOffset, to: currentDate)!
-        let entry = SimpleEntry(date: entryDate, configuration: configuration)
-        entries.append(entry)
-    }
-
-    return Timeline(entries: entries, policy: .atEnd)
+    let data = DataManager.shared.loadSampleData()
+    let entry = SimpleEntry(date: Date(), sampleList: data, configuration: configuration)
+
+    // 0時に更新
+    let calendar = Calendar.current
+    let now = Date()
+    let nextMidnight = calendar.nextDate(
+        after: now,
+        matching: DateComponents(hour: 0, minute: 0),
+        matchingPolicy: .nextTime
+    )!
+
+    return Timeline(entries: [entry], policy: .after(nextMidnight))
}

struct SimpleEntry: TimelineEntry {
    let date: Date
+   let sampleList: [SampleModel]
    let configuration: ConfigurationAppIntent
}

struct widgetEntryView : View {
    var entry: Provider.Entry

    var body: some View {
        VStack {
-           Text("Time:")
-           Text(entry.date, style: .time)
-
-           Text("Hello Widget")
+           ForEach(entry.sampleList, id: \.id) { sample in
+               Text(sample.name)
+           }
        }
    }
}
```

修正後、`npm run ios`コマンドでアプリをビルドします。
取得したデータを表示することができました。

![](https://storage.googleapis.com/zenn-user-upload/dac1350d0fa9-20251130.png)

ここまで完了すれば、実際に表示したいデータを取得するように`DataManager.swift`を修正したり、表示したいように`widget.swift`の`View`を編集することで、ウィジェットを構築していくことが可能です。

## データをアプリ本体と共通化する

### 共通化の概要
アプリ本体とWidget間でデータをやり取りしたい場合にApp Groupがよく使われます。
App Groupは隔離されたサンドボックス環境を超えて安全にデータを共有できるようにする仕組みです。
今回の自分が作成したアプリはローカル完結のアプリでSQLiteにデータを保存しているので、今回の例でもアプリ本体とウィジェットから共有のSQLiteのファイルにアクセスできるようにします。
他にはUserDefaultsなどがよく使われるみたいです。

### アプリ本体からApp Groupのファイルにアクセスする


Expo公式のドキュメントに従って進めていきます。

https://docs.expo.dev/versions/latest/sdk/sqlite/

ライブラリをインストールします。
```
npx expo install expo-sqlite
```



### ウィジェットからApp Groupのファイルにアクセスする


## 表示更新をアプリと同期する

refresh
更新して同期する方法

## ウィジェットから環境変数を使う

## 開発環境と分ける

widgetとgroup idの書き換え
[https://github.com/EvanBacon/expo-apple-targets/issues/106](https://github.com/EvanBacon/expo-apple-targets/issues/106)

## 参考

https://docs.expo.dev/workflow/continuous-native-generation
https://github.com/EvanBacon/expo-apple-targets
https://tech.fusic.co.jp/posts/expo-apple-widget/
https://qiita.com/yuuka_____gf/items/604c29a71584206f23d3
